package evolvingWilds.vinny;



/**
 * @author Mario LoPrinzi
 * @date 3/24/14
 * 
 */

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.Arrays;
import java.util.Vector;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSlider;
import javax.swing.JTable;
import javax.swing.JToggleButton;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableModel;

import creature.phenotype.Block;
import creature.phenotype.Creature;
import creature.phenotype.EnumJointSite;
import creature.phenotype.EnumJointType;
import creature.phenotype.EnumNeuronInputType;
import creature.phenotype.EnumOperatorBinary;
import creature.phenotype.EnumOperatorUnary;
import creature.phenotype.Joint;
import creature.phenotype.NeuronInput;
import creature.phenotype.Rule;
import creature.phenotype.Vector3;

@SuppressWarnings("serial")
public class GUIFrame extends JFrame implements ActionListener, Runnable
{

  // Define constants for the top-level container
  private static String TITLE = "Fireworks display! Jogl Lab"; // window's
  static final int PANEL_WIDTH = 200; // title
  private static final int CANVAS_WIDTH = 640 - PANEL_WIDTH; // width of the
                                                             // drawable
  private static final int CANVAS_HEIGHT = 480; // height of the drawable

  // Create the OpenGL rendering canvas
  private int creatureNum = 0;
  private int tribeNum = Runtime.getRuntime().availableProcessors();
  private final Canvas canvas = new Canvas();
  private JPanel rightPanel = new JPanel();
  private JPanel graphicsPanel = new JPanel();
  private JButton pause = new JButton("Pause");
  private JButton nextGen = new JButton("Next Gen");
  private JToggleButton aniCreature = new JToggleButton("Animate Creature");
  private JButton table = new JButton("Print Table");
  private JButton save = new JButton("Save");
  private JLabel sliderLabel1 = new JLabel("Tribe Number");
  private JSlider slider1 = new JSlider();
  private JLabel sliderLabel2 = new JLabel("Which Creature");
  private JSlider slider2 = new JSlider();
  private JTable creatureTable = new JTable();
  private boolean paused = false;

  @Override
  public void actionPerformed(ActionEvent e)
  {
    if (e.getSource() == aniCreature)
    {
      this.pauseGL();
    }

    else if (e.getSource() == pause)
    {
      // stop entire evolution process
    }

    else if (e.getSource() == nextGen)
    {
      // call resources necessary for running 1 generation
      this.updateData();
    }

    else if (e.getSource() == table)
    {
      // show the phenotype of a table
      this.toTable();
    }

    else if (e.getSource() == slider1)
    {
      // select the tribe
      this.updateData();
    }

    else if (e.getSource() == slider2)
    {
      // select the creature on the tribe
      this.updateData();
    }

  }

  public GUIFrame()
  {
    pause.addActionListener(this);

    nextGen.addActionListener(this);

    aniCreature.addActionListener(this);

    table.addActionListener(this);

    save.addActionListener(this);

  }

  /**
   * runs the intial start up of the gui and maintains it as events are called
   */
  public void run()
  {

    slider1.setMaximum(tribeNum);
    slider1.setMinimum(1);
    graphicsPanel.setLayout(new BorderLayout());

    graphicsPanel.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
    graphicsPanel.setMaximumSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
    graphicsPanel.setMinimumSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));

    rightPanel.setSize(PANEL_WIDTH, CANVAS_HEIGHT);
    rightPanel.setMaximumSize(new Dimension(PANEL_WIDTH, CANVAS_HEIGHT));
    rightPanel.setMinimumSize(new Dimension(PANEL_WIDTH, CANVAS_HEIGHT));
    rightPanel.setBackground(new Color(255, 0, 0));

    canvas.setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
    canvas.setMinimumSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
    canvas.setMaximumSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));

    // Create the top-level container
    final GUIFrame frame = new GUIFrame();
    frame.setLayout(new BorderLayout());
    frame.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
    frame.setMinimumSize(new Dimension(CANVAS_WIDTH + PANEL_WIDTH,
        CANVAS_HEIGHT));
    frame.setMaximumSize(new Dimension(CANVAS_WIDTH + PANEL_WIDTH,
        CANVAS_HEIGHT));
    rightPanel.add(pause);
    rightPanel.add(nextGen);
    rightPanel.add(aniCreature);
    rightPanel.add(table);
    rightPanel.add(save);
    rightPanel.add(sliderLabel1);
    rightPanel.add(slider1);
    rightPanel.add(sliderLabel2);
    rightPanel.add(slider2);
    rightPanel.add(creatureTable);

    graphicsPanel.add(canvas);
    frame.add(rightPanel);
    frame.add(graphicsPanel);
    frame.setResizable(false);
    frame.addWindowListener(new WindowAdapter()
    {
      @Override
      public void windowClosing(WindowEvent e)
      {
        // Use a dedicate thread to run the stop() to ensure that the
        // animator stops before program exits.
        new Thread()
        {
          @Override
          public void run()
          {
            if (canvas.getAnimator().isStarted())
              canvas.getAnimator().stop();
            System.exit(0);
          }
        }.start();
      }
    });
    frame.setTitle(TITLE);
    frame.pack();
    frame.setVisible(true);
  }

  public void updateData()
  {
    // grab creature and populate the data
    tribeNum = slider1.getValue();
    creatureNum = slider2.getValue();

    System.out.println(tribeNum + " " + creatureNum);
  }

  public void pauseGL()
  {
    if (paused)
    {
      canvas.animator.resume();
      paused = false;
    }
    else
    {
      canvas.animator.pause();
      paused = true;
    }
  }

  private void toTable()
  {
    // /////////////////////////////
    Vector3 rootForward = Vector3.FORWARD;
    Vector3 rootUp = Vector3.UP;

    Block[] body = new Block[6];
    body[0] = new Block(Block.PARENT_INDEX_NONE, null, 8, 8, 2);

    Joint joint1 = new Joint(EnumJointType.SPHERICAL,
        EnumJointSite.VERTEX_FRONT_NORTHEAST,
        EnumJointSite.VERTEX_FRONT_NORTHEAST, 0f);
    Joint joint2 = new Joint(EnumJointType.RIGID,
        EnumJointSite.VERTEX_FRONT_NORTHWEST,
        EnumJointSite.VERTEX_FRONT_NORTHEAST, 0f);

    Joint joint3 = new Joint(EnumJointType.HINGE,
        EnumJointSite.VERTEX_BACK_NORTHEAST, EnumJointSite.EDGE_BACK_NORTH, 0f);
    Joint joint4 = new Joint(EnumJointType.TWIST,
        EnumJointSite.VERTEX_BACK_NORTHWEST, EnumJointSite.EDGE_BACK_NORTH, 0f);

    Rule rule1 = new Rule();
    NeuronInput neuron1A = new NeuronInput(EnumNeuronInputType.TOUCH, 0);
    NeuronInput neuron1B = new NeuronInput(EnumNeuronInputType.CONSTANT, 5.2f);
    NeuronInput neuron1C = new NeuronInput(EnumNeuronInputType.CONSTANT, 0.0f);
    NeuronInput neuron1D = new NeuronInput(EnumNeuronInputType.CONSTANT, 2.0f);
    NeuronInput neuron1E = new NeuronInput(EnumNeuronInputType.TIME);
    rule1.setInput(neuron1A, NeuronInput.A);
    rule1.setInput(neuron1B, NeuronInput.B);
    rule1.setInput(neuron1C, NeuronInput.C);
    rule1.setInput(neuron1D, NeuronInput.D);
    rule1.setInput(neuron1E, NeuronInput.E);
    rule1.setOp1(EnumOperatorBinary.MULTIPLY);
    rule1.setOp2(EnumOperatorUnary.IDENTITY);
    rule1.setOp3(EnumOperatorBinary.MULTIPLY);
    rule1.setOp4(EnumOperatorUnary.SIN);
    joint1.addRule(rule1, 0);

    Rule rule2 = new Rule();
    NeuronInput neuron2A = new NeuronInput(EnumNeuronInputType.JOINT, 4, 1);
    NeuronInput neuron2B = new NeuronInput(EnumNeuronInputType.JOINT, 3, 1);
    NeuronInput neuron2C = new NeuronInput(EnumNeuronInputType.CONSTANT, 0.5f);
    NeuronInput neuron2D = new NeuronInput(EnumNeuronInputType.CONSTANT, 10.0f);
    NeuronInput neuron2E = new NeuronInput(EnumNeuronInputType.CONSTANT, 0.0f);
    rule2.setInput(neuron2A, NeuronInput.A);
    rule2.setInput(neuron2B, NeuronInput.B);
    rule2.setInput(neuron2C, NeuronInput.C);
    rule2.setInput(neuron2D, NeuronInput.D);
    rule2.setInput(neuron2E, NeuronInput.E);
    rule2.setOp1(EnumOperatorBinary.SUBTRACT);
    rule2.setOp2(EnumOperatorUnary.IDENTITY);
    rule2.setOp3(EnumOperatorBinary.ADD);
    rule2.setOp4(EnumOperatorUnary.IDENTITY);
    joint1.addRule(rule2, 1);

    Rule rule3 = new Rule();
    NeuronInput neuron3A = new NeuronInput(EnumNeuronInputType.JOINT, 3, 1);
    NeuronInput neuron3B = new NeuronInput(EnumNeuronInputType.JOINT, 4, 1);
    NeuronInput neuron3C = new NeuronInput(EnumNeuronInputType.CONSTANT, 0.5f);
    NeuronInput neuron3D = new NeuronInput(EnumNeuronInputType.JOINT, 1, 1);
    NeuronInput neuron3E = new NeuronInput(EnumNeuronInputType.CONSTANT, 3.3f);
    rule3.setInput(neuron3A, NeuronInput.A);
    rule3.setInput(neuron3B, NeuronInput.B);
    rule3.setInput(neuron3C, NeuronInput.C);
    rule3.setInput(neuron3D, NeuronInput.D);
    rule3.setInput(neuron3E, NeuronInput.E);
    rule3.setOp1(EnumOperatorBinary.SUBTRACT);
    rule3.setOp2(EnumOperatorUnary.IDENTITY);
    rule3.setOp3(EnumOperatorBinary.MULTIPLY);
    rule3.setOp4(EnumOperatorUnary.IDENTITY);
    joint1.addRule(rule3, 1);

    body[1] = new Block(0, joint1, 2, 4, 6);
    body[2] = new Block(0, joint2, 2, 4, 6);
    body[3] = new Block(0, joint3, 2, 4, 6);
    body[4] = new Block(0, joint4, 2, 4, 6);

    Joint joint5 = new Joint(EnumJointType.HINGE, EnumJointSite.FACE_FRONT,
        EnumJointSite.EDGE_BACK_NORTH, (float) (Math.PI / 2.0));
    body[5] = new Block(4, joint5, 1, 3, 1);

    Creature creature = new Creature(body, rootForward, rootUp);
    // ///////////////////

    String rows[] = creature.toString().split("\n");

    Vector<Vector<String>> dataVector = new Vector<Vector<String>>();
    for (String row : rows)
    {
      row = row.trim(); // UPDATE

      Vector<String> data = new Vector<String>();
      data.addAll(Arrays.asList(row));
      dataVector.add(data);
    }
    Vector<String> header = new Vector<String>();

    creatureNum = slider2.getValue();
    header.add("Creature: " + creatureNum);

    TableModel model = new DefaultTableModel(dataVector, header);
    creatureTable = new JTable(model);
    JScrollPane creaturePane = new JScrollPane(creatureTable);
    JFrame frame2 = new JFrame("PhenoType");
    frame2.add(creaturePane);
    frame2.setSize(350, 250);
    frame2.setVisible(true);
    frame2.setLocation(640, 0);
    frame2.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  }
}
